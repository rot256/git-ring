package ring

import (
	"crypto"
	"crypto/ed25519"
	"crypto/rsa"
	"log"

	"golang.org/x/crypto/ssh"
)

type Signature struct {
	Msg          []byte
	Proofs       [][]byte
	Challenges   []challenge
	Fingerprints []string
}

func setupTranscript(pks []PublicKey, msg []byte) *transcript {
	tx := NewTranscript()
	tx.Append(msg)
	for _, pk := range pks {
		tx.Append([]byte(ssh.FingerprintSHA256(pk.pk)))
	}
	return tx
}

func (sig *Signature) Verify(pks []PublicKey) []byte {
	// index by fingerprints
	keyMap := make(map[string]PublicKey)
	for _, pk := range pks {
		keyMap[pk.FP()] = pk
	}

	// lookup subset of keys included in the signature
	// (the signature might be for a smaller ring, e.g. keys may have been added later)
	selectPks := make([]PublicKey, 0, len(sig.Fingerprints))
	for _, fp := range sig.Fingerprints {
		if pk, ok := keyMap[fp]; ok {
			selectPks = append(selectPks, pk)
		} else {
			return nil
		}
	}

	return sig.VerifyExact(selectPks)
}

func (sig *Signature) VerifyExact(pks []PublicKey) []byte {
	// commit to statement (list of public key)
	tx := setupTranscript(pks, sig.Msg)

	// basic checks
	if len(sig.Proofs) != len(pks) {
		return nil
	}
	if len(sig.Challenges) != len(pks) {
		return nil
	}
	if len(sig.Fingerprints) != len(pks) {
		return nil
	}

	// verify every proof
	for i, pk := range pks {
		// check fingerprint hint included in signature
		if pk.FP() != sig.Fingerprints[i] {
			return nil
		}

		// pick proof type (based on public key)
		var pf proof
		switch pk.pk.Type() {
		case ssh.KeyAlgoED25519:
			pf = &ed25519Proof{}
		case ssh.KeyAlgoRSA:
			pf = &rsaProof{}
		default:
			log.Fatalln("Unsupported key type:", pk.pk.Type())
		}

		// unmarshal proof
		if err := pf.Unmarshal(sig.Proofs[i]); err != nil {
			return nil
		}

		// check that challenge is right size
		chal := sig.Challenges[i]
		if !chal.IsValid() {
			return nil
		}

		// verify proof against challenge
		ckey := pk.pk.(ssh.CryptoPublicKey).CryptoPublicKey()
		if !pf.Verify(ckey, chal) {
			return nil
		}
		pf.Commit(tx)
	}

	// final check: challenges sum to zero
	delta := tx.Challenge()
	for _, chal := range sig.Challenges {
		delta.Add(chal)
	}

	if delta.IsZero() {
		return sig.Msg
	} else {
		return nil
	}
}

func Sign(pair KeyPair, pks []PublicKey, msg []byte) Signature {
	// commit to statement (list of public key)
	tx := setupTranscript(pks, msg)

	index := len(pks)
	for i := range pks {
		if pair.PK.Equals(pks[i]) {
			index = i
		}
	}

	// sanity checks
	if index == len(pks) {
		panic("public keys does not contain pair, this is a bug.")
	}
	if msg == nil {
		panic("nil message")
	}

	// generate random challenges for in-active clauses
	challenges := make([]challenge, len(pks))
	for i := range challenges {
		if i != index {
			challenges[i].Random()
		}
	}

	// construct appropiate prover
	var prover prover
	skCkey := pair.SK.(crypto.PrivateKey)

	// detect ed25519 key
	if sk, ok := skCkey.(*ed25519.PrivateKey); ok {
		prover = proveEd25519(*sk)
	}

	// detect RSA key
	if sk, ok := skCkey.(*rsa.PrivateKey); ok {
		prover = proveRSA(sk)
	}

	if prover == nil {
		log.Fatalln("Unsupported signing key")
	}

	// the proof for the active index is generated by the honest prover
	pfs := make([]proof, len(pks))
	pfs[index] = prover.Pf()

	// simulate in-active clauses using SHVZK sim.
	for i, pk := range pks {
		if i == index {
			continue
		}

		ckey := pk.pk.(ssh.CryptoPublicKey).CryptoPublicKey()
		chal := challenges[i]

		switch pk.pk.Type() {
		case ssh.KeyAlgoED25519:
			pfs[i] = ed25519Sim(ckey.(ed25519.PublicKey), chal)
		case ssh.KeyAlgoRSA:
			pfs[i] = rsaSim(ckey.(*rsa.PublicKey), chal)
		default:
			log.Fatalln("Unsupported key type:", pk.pk.Type())
		}
	}

	// commit to first round messages
	for _, pf := range pfs {
		pf.Commit(tx)
	}

	// sample challenge
	challenges[index] = tx.Challenge()

	// compute challenge for active clause
	// (challenges and tx.Challenge sums to 0)
	for i, chal := range challenges {
		if i != index {
			challenges[index].Add(chal)
		}
	}

	// finish transcript for active clause
	prover.Finish(challenges[index])
	pfs[index] = prover.Pf()

	// compile combined signature
	sig := Signature{
		Msg:          msg,
		Challenges:   challenges,
		Proofs:       make([][]byte, len(pfs)),
		Fingerprints: make([]string, len(pks)),
	}

	// serialize all the proofs
	for i, pf := range pfs {
		sig.Proofs[i] = pf.Marshal()
	}

	// add fingerprints to signature
	// (to enable verifying against a superset of keys)
	for i, pk := range pks {
		sig.Fingerprints[i] = ssh.FingerprintSHA256(pk.pk)
	}

	// check validity of generated signature: sanity check
	if sig.VerifyExact(pks) == nil {
		panic("signature does not verify")
	}

	return sig
}
