package main

import (
	"crypto"
	"crypto/ed25519"
	"crypto/rsa"
	"log"

	"golang.org/x/crypto/ssh"
)

type Signature struct {
	Proofs       [][]byte
	Challenges   []Challenge
	Fingerprints []string
}

func newTranscript(pks []PublicKey) *Transcript {
	tx := NewTranscript()
	for _, pk := range pks {
		tx.Append([]byte(ssh.FingerprintSHA256(pk.pk)))
	}
	return tx
}

func (sig *Signature) VerifyExact(pks []PublicKey) bool {
	tx := newTranscript(pks)

	// basic checks
	if len(sig.Proofs) != len(pks) {
		return false
	}
	if len(sig.Challenges) != len(pks) {
		return false
	}
	if len(sig.Fingerprints) != len(pks) {
		return false
	}

	// verify every proof
	for i, pk := range pks {
		// check fingerprint hint included in signature
		if ssh.FingerprintSHA256(pk.pk) != sig.Fingerprints[i] {
			return false
		}

		// pick proof type (based on public key)
		var pf Proof
		switch pk.pk.Type() {
		case ssh.KeyAlgoED25519:
			pf = &ed25519Proof{}
		case ssh.KeyAlgoRSA:
			pf = &rsaProof{}
		default:
			log.Fatalln("Unsupported key type:", pk.pk.Type())
		}

		// unmarshal proof
		if err := pf.Unmarshal(sig.Proofs[i]); err != nil {
			return false
		}

		// check that challenge is right size
		chal := sig.Challenges[i]
		if !chal.IsValid() {
			return false
		}

		// verify proof against challenge
		ckey := pk.pk.(ssh.CryptoPublicKey).CryptoPublicKey()
		if !pf.Verify(ckey, chal) {
			return false
		}
		pf.Commit(tx)
	}

	// check that challenges sum to zero
	delta := tx.Challenge()
	for _, chal := range sig.Challenges {
		delta.Add(chal)
	}
	return delta.IsZero()
}

func ringSign(pair KeyPair, pks []PublicKey) Signature {

	index := len(pks)
	for i := range pks {
		if pair.pk.Equals(pks[i]) {
			index = i
		}
	}

	// sanity check
	if index == len(pks) {
		panic("public keys does not contain pair, this is a bug.")
	}

	// generate random challenges for in-active clauses
	challenges := make([]Challenge, len(pks))
	for i := range challenges {
		if i != index {
			challenges[i].Random()
		}
	}

	// commit to statement (list of public key)
	tx := newTranscript(pks)

	var prover Prover

	skCkey := pair.sk.(crypto.PrivateKey)

	// detect ed25519 key
	if sk, ok := skCkey.(*ed25519.PrivateKey); ok {
		prover = proveEd25519(*sk)
	}

	// detect RSA key
	if sk, ok := skCkey.(*rsa.PrivateKey); ok {
		prover = proveRSA(sk)
	}

	if prover == nil {
		log.Fatalln("Unsupported signing key")
	}

	// the proof for the active index is generated by the honest prover
	pfs := make([]Proof, len(pks))
	pfs[index] = prover.Pf()

	// simulate in-active clauses using SHVZK sim.
	for i, pk := range pks {
		if i == index {
			continue
		}

		ckey := pk.pk.(ssh.CryptoPublicKey).CryptoPublicKey()
		chal := challenges[i]

		switch pk.pk.Type() {
		case ssh.KeyAlgoED25519:
			pfs[i] = ed25519Sim(ckey.(ed25519.PublicKey), chal)
		case ssh.KeyAlgoRSA:
			pfs[i] = rsaSim(ckey.(*rsa.PublicKey), chal)
		default:
			log.Fatalln("Unsupported key type:", pk.pk.Type())
		}
	}

	// commit to first round messages
	for _, pf := range pfs {
		pf.Commit(tx)
	}

	// sample challenge
	challenges[index] = tx.Challenge()

	// compute challenge for active clause
	// (challenges and tx.Challenge sums to 0)
	for i, chal := range challenges {
		if i != index {
			challenges[index].Add(chal)
		}
	}

	// finish transcript for active clause
	prover.Finish(challenges[index])
	pfs[index] = prover.Pf()

	// compile combined signature
	sig := Signature{
		Challenges:   challenges,
		Proofs:       make([][]byte, len(pfs)),
		Fingerprints: make([]string, len(pks)),
	}

	// serialize all the proofs
	for i, pf := range pfs {
		sig.Proofs[i] = pf.Marshal()
	}

	// add fingerprints to signature
	// (to enable verifying against a superset of keys)
	for i, pk := range pks {
		sig.Fingerprints[i] = ssh.FingerprintSHA256(pk.pk)
	}

	// check validity of generated signature: sanity check
	if !sig.VerifyExact(pks) {
		panic("signature does not verify")
	}

	return sig
}
