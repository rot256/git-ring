package ring

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/ed25519"
	"crypto/rsa"
	"crypto/sha512"
	"encoding/binary"
	"fmt"
	"log"

	"golang.org/x/crypto/ssh"
)

const version = 1

type Signature struct {
	Version      int
	Proofs       [][]byte
	Challenges   []challenge
	Fingerprints []string
	Msg          []byte
}

func setupTranscript(pks []PublicKey, msg []byte) *transcript {
	tx := NewTranscript()

	// include version in transcript
	var versionBytes [4]byte
	binary.BigEndian.PutUint32(versionBytes[:], uint32(version))
	tx.Append(versionBytes[:])

	// add message to transcript
	//
	// We hash the message first to enable streaming in the future:
	// signing a big file without keeping it in memory.
	hash := sha512.Sum512(msg)
	tx.Append(hash[:])

	// add public keys
	for _, pk := range pks {
		tx.Append([]byte(pk.FP()))
	}
	return tx
}

func Sign(pair KeyPair, pks []PublicKey, msg []byte) Signature {
	// commit to statement (list of public key)
	tx := setupTranscript(pks, msg)

	// retrieve the index of the signer
	index := len(pks)
	for i := range pks {
		if pair.PK.Equals(pks[i]) {
			index = i
		}
	}

	// sanity checks
	if index == len(pks) {
		panic("public keys does not contain pair, this is a bug.")
	}

	// generate random challenges for in-active clauses
	challenges := make([]challenge, len(pks))
	for i := range challenges {
		if i != index {
			challenges[i].Random()
		}
	}

	// construct appropiate prover
	var prover prover
	skCkey := pair.SK.(crypto.PrivateKey)

	// detect ed25519 key
	if sk, ok := skCkey.(*ed25519.PrivateKey); ok {
		prover = ed25519Prove(*sk)
	}

	// detect RSA key
	if sk, ok := skCkey.(*rsa.PrivateKey); ok {
		prover = rsaProve(sk)
	}

	if sk, ok := skCkey.(*ecdsa.PrivateKey); ok {
		prover = ecdsaProve(sk)
	}

	if prover == nil {
		panic(fmt.Errorf("unrecognized private key-type %T", skCkey))
	}

	// the proof for the active index is generated by the honest prover
	pfs := make([]proof, len(pks))
	pfs[index] = prover.Pf()

	// simulate in-active clauses using SHVZK sim.
	for i, pk := range pks {
		if i == index {
			continue
		}

		chal := challenges[i]
		ckey := toCryptoPublicKey(pk)

		switch pk.pk.Type() {
		case ssh.KeyAlgoSKED25519, ssh.KeyAlgoED25519:
			pfs[i] = ed25519Sim(ckey.(ed25519.PublicKey), chal)
		case ssh.KeyAlgoRSA:
			pfs[i] = rsaSim(ckey.(*rsa.PublicKey), chal)
		case ssh.KeyAlgoSKECDSA256, ssh.KeyAlgoECDSA256, ssh.KeyAlgoECDSA384, ssh.KeyAlgoECDSA521:
			pfs[i] = ecdsaSim(ckey.(*ecdsa.PublicKey), chal)
		default:
			log.Fatalln("unsupported key type:", pk.pk.Type())
		}
	}

	// commit to first round messages
	for _, pf := range pfs {
		pf.Commit(tx)
	}

	// sample challenge
	challenges[index] = tx.Challenge()

	// compute challenge for active clause
	// (challenges and tx.Challenge sums to 0)
	for i, chal := range challenges {
		if i != index {
			challenges[index].Add(chal)
		}
	}

	// finish transcript for active clause
	prover.Finish(challenges[index])
	pfs[index] = prover.Pf()

	// compile combined signature
	sig := Signature{
		Version:      version,
		Msg:          msg,
		Challenges:   challenges,
		Proofs:       make([][]byte, len(pfs)),
		Fingerprints: make([]string, len(pks)),
	}

	// serialize all the proofs
	for i, pf := range pfs {
		sig.Proofs[i] = pf.Marshal()
	}

	// add fingerprints to signature
	// (to enable verifying against a superset of keys)
	for i, pk := range pks {
		sig.Fingerprints[i] = ssh.FingerprintSHA256(pk.pk)
	}

	// check validity of generated signature: sanity check
	if _, err := sig.VerifyExact(pks); err != nil {
		panic(err)
	}

	return sig
}
